::::::: {#topic3}
## Topic 3: The Concept of Complex Frequency

Complex frequency is found commonly in electrical engineering. It is often notated as $j\omega$ or $s = \sigma \pm j\omega$. These frequencies always come in pairs, so the use of $\pm$ is implicit to this, as complex numbers have complex conjugates (normally notated by $z^*$ or $\bar{z}$). i.e. $s = \sigma + j\omega$ has the conjugate $s=\sigma - j\omega$.

::: {#argand-figure}
```{python}
#| fig-align: center
#| fig-cap: Argand diagram of $|z| = \sqrt{2}$
#| label: fig:argand
#| echo: false
import matplotlib.pyplot as plt
from matplotlib import font_manager
import numpy as np
import mpl_toolkits.axisartist as AA
font_dirs = ["C:/Users/narus/AppData/Local/Microsoft/Windows/Fonts/"]
font_files = font_manager.findSystemFonts(fontpaths=font_dirs)
for font_file in font_files:
    font_manager.fontManager.addfont(font_file)

plt.rcParams.update({
    'font.family': 'latin modern math',
    'mathtext.fontset': 'cm',
    'font.size': 12  # Set the font size
})
# plt.rcdefaults()
# Create a figure
fig = plt.figure()
ax = fig.add_axes([0.1, 0.1, 0.8, 0.8], axes_class=AA.AxesZero)

# Customize the axes
for direction in ["xzero", "yzero"]:
    ax.axis[direction].set_axisline_style("-|>")
    ax.axis[direction].set_visible(True)

for direction in ["left", "right", "bottom", "top"]:
    ax.axis[direction].set_visible(False)
ax.set_aspect('equal')
# Set the x and y bounds
ax.set_xlim(-2, 2)
ax.set_ylim(-2, 2)

# Plot the circle |z| = sqrt(2)
theta = np.linspace(0, 2 * np.pi, 100)
x_circle = np.sqrt(2) * np.cos(theta)
y_circle = np.sqrt(2) * np.sin(theta)
ax.plot(x_circle, y_circle, color='black')

# Plot the complex numbers
complex_numbers = [1 + 1j, 1 - 1j, -1 + 1j, -1 - 1j]
for z in complex_numbers:
    ax.plot(z.real, z.imag, 'ro')  # Plot each point as a blue circle
# Draw vectors from the origin to each complex number using quiver
real_parts = [z.real for z in complex_numbers]
imaginary_parts = [z.imag for z in complex_numbers]
# Draw vectors from the origin to each complex number using quiver
ax.quiver([0]*len(complex_numbers), [0]*len(complex_numbers),
          real_parts, imaginary_parts, angles='xy', scale_units='xy', scale=1, color='blue')
ax.text(2.05, 0.05, r'$\mathrm{Re(z)}$', ha='right', va='bottom')
ax.text(0.05, 2.05, r'$\mathrm{Im(z)}$', ha='left', va='bottom')
# Optionally, add a grid for better alignment
ax.grid(True, alpha=0.5)
ax.set_xticks([-2, -1, 1, 2])
ax.set_yticks([-2, -1, 1, 2])
# Ensure that the tick labels are using the correct font
# Display the plot
plt.show()
```
:::

::: {#de-moivre-formula}
This is also backed up by De Moivre's formula which is defined mathematically as:
```{=latex}
\begin{gather}
    \label{eq:de-moivre-formula}
    \forall x \in \mathbb{R}, \quad \forall n \in \mathbb{Z}, \\
    e^{jnx} = \cos(n x) + j \sin(n x)  
\end{gather}
```
:::

::: {#de-moivre-formula-general}
Or more generally for our applications (this is also known as Euler's formula):
```{=latex}
\begin{gather}
    \label{eq:de-moivre-formula-general}
    e^{jx} = \cos(x) + j \sin(x) \\
    \text{Where} \, x \in \mathbb{R}\, \text{(\(x\) is real)} \\
    \text{and} \, j \equiv i = \sqrt{-1}
\end{gather}
```
:::

::: {#complex-sinusoid-def-1}
```{=latex}
This means that:\\
\begin{mdframed}
    \begin{center}
        \redtext{\emph{A complex frequency \(j\omega \) represents a pure sinusoidal signal of frequency \(\omega \) \unit{\rads}}}
    \end{center}
\end{mdframed}
```
:::
:::::::