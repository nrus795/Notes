{"title":"COMPSYS 303: Microcomputers and Embedded Systems","markdown":{"headingText":"SoC and SOPC Buses","containsRefs":false,"markdown":"<!-- lecture5_sopc_buses.qmd -->\n\n\n## Introduction to SoC and SOPC\n\n**System-on-Chip (SoC)** and **System-on-Programmable-Chip (SOPC)** are key technologies in modern embedded systems. These technologies combine multiple functional blocks, such as processors, memory, and peripherals, onto a single chip. They use **buses** to facilitate communication between these components (Slide 1). Buses are fundamental to the functionality of SoC and SOPC designs, as they determine how different modules interact, ensuring reliable data transfer and system performance.\n\n## Internal vs External Buses\n\nBuses can be broadly classified into **internal** and **external** types based on their scope within a system (Slide 9):\n\n**Internal Buses**: These are used within a single chip or a tightly integrated board to connect different functional blocks. Examples include:\n\n-   **PCI** (Peripheral Component Interconnect)\n\n-   **AGP** (Accelerated Graphics Port)\n\n-   **PCMCIA**\n\n-   **AMBA** (Advanced Microcontroller Bus Architecture) for ARM-based systems\n\n-   **Avalon** buses used in Altera's SOPC designs\n\n**External Buses**: These are used to connect different chips or boards. Examples include:\n\n-   **USB** (Universal Serial Bus)\n\n-   **FireWire** (Some dumb apple proprietary thing)\n\n## Bus Design Issues\n\nThe design of a bus impacts system performance, scalability, and cost. Several factors must be considered when designing a bus (Slide 14):\n\n**Bus Width**: The width of the data and address buses is a critical determinant of the system's performance. A wider bus can transfer more data per cycle but is more expensive to implement. For example, a Pentium processor has a 32-bit instruction set architecture (ISA) but a 64-bit data bus, while an Itanium processor has a 128-bit data bus, offering significantly more bandwidth for data transfers (Slides 15-16).\n\n**Bus Type**: Buses can be **dedicated** or **multiplexed**:\n\n-   **Dedicated Buses** have separate lines for data and address information, providing better performance but increasing costs.\n\n-   **Multiplexed Buses** share the same lines for data and address, which reduces cost and resource usage but may introduce delays in data transmission (Slide 17).\n\n## Bus Operations\n\n**Bus operations** define how data is transferred between components (Slide 18). Common bus operations include:\n\n-   **Read and Write**: Basic data transfer operations.\n\n-   **Block Transfer**: A series of contiguous memory locations are read or written in sequence, useful for operations like filling a cache line.\n\n-   **Read-Modify-Write**: Often used for critical sections where multiple operations must be performed atomically.\n\n-   **Interrupt Operation**: A mechanism for peripherals to request the processor's attention, triggering an interrupt service routine.\n\n## Synchronous vs Asynchronous Buses\n\n### Synchronous Bus\n\nA **synchronous bus** uses a **bus clock signal** to synchronize all actions on the bus (Slide 19). Characteristics of synchronous buses include:\n\n-   **Clock Edge Coordination**: All data transfers occur relative to a clock signal, simplifying timing design.\n\n-   **Wait States**: A synchronous bus may operate with **wait states** if the target device is not ready for a data transfer. Without wait states, data transfers occur at the maximum clock speed, but adding wait states ensures reliable operation if the target is slower (Slides 20-24).\n\n-   **Block Transfers**: Synchronous buses also support **block transfers**, which allow multiple data units to be transferred in a single bus transaction, improving throughput (Slide 24).\n\n### Asynchronous Bus\n\nAn **asynchronous bus** does not use a clock signal to synchronize actions. Instead, it relies on **handshaking signals** to control data transfer between the master and slave (Slide 25). Features include:\n\n-   **Handshaking Protocol**: Two synchronization signals, **Master Synchronization (MSYN)** and **Slave Synchronization (SSYN)**, ensure that the sender and receiver are ready for each data transfer.\n\n-   **No Clock Dependency**: This allows asynchronous buses to be more flexible, as they do not require a fixed clock frequency. However, implementing the handshaking mechanism can be more complex compared to synchronous buses.\n\n## Bus Arbitration\n\nIn systems with multiple masters (e.g., CPUs, DMA controllers), **bus arbitration** is required to manage access to the bus (Slide 27). Arbitration mechanisms include:\n\n-   **Static Arbitration**: Allocates the bus in a fixed, predetermined manner. While easy to implement, this approach can lead to poor utilization and potential bus monopolization by one master (Slide 28).\n\n-   **Dynamic Bus Arbitration**: Allocates the bus only when a master requests it, allowing more efficient use of resources. Masters use **bus request** and **bus grant** lines to signal their need for the bus and receive permission to use it. Dynamic arbitration supports various allocation policies (Slides 28-40):\n\n    -   **Fixed Priority**: Assigns a fixed priority to each master, but may lead to **bus hogging** by high-priority devices.\n\n    -   **Rotating Priority**: Changes the priority of masters dynamically to prevent starvation. The **lowest priority** is assigned to the master that just used the bus, ensuring fair access.\n\n    -   **Fair Policies**: Ensure that no master is starved of the bus. These policies can be based on **time windows** to guarantee a maximum delay before a bus request is granted.\n\n-   **Bus Release Policies**: Determine when the current master releases the bus. Two types of policies are:\n\n    -   **Non-Preemptive Release**: The master voluntarily releases the bus after completing the current transaction. This is easy to implement but can lead to inefficient bus usage if the master holds the bus unnecessarily (Slide 40).\n\n    -   **Preemptive Release**: Forces the current master to release the bus, which can be useful for handling urgent requests from other masters.\n\n### Bus Arbitration Implementation\n\n-   **Centralized Bus Arbitration**: Uses a **daisy-chaining** method where the bus grant signal is passed down a chain of masters. It is easy to implement but has several drawbacks, such as fixed priority and increased arbitration time proportional to the number of masters (Slide 37).\n\n-   **Independent Requests**: Each master has a dedicated bus request line to the central arbiter. This approach is more fault-tolerant and allows for **constant arbitration time**, but requires a higher number of control signals (Slide 39).\n\n-   **Hybrid Arbitration Schemes**: Combine features of daisy-chaining and independent requests. For example, bus masters can be grouped into **classes**, with independent arbitration at the class level and daisy-chaining within each class. This provides a balance between cost and performance (Slide 40).\n\n## System Bus Components\n\nThe system bus consists of the following components:\n\n-   **Address Bus**: Carries the addresses from the master to the slave, specifying the location for read or write operations.\n\n-   **Data Bus**: Transfers actual data between components.\n\n-   **Control Bus**: Carries control signals, such as read/write enable, to coordinate the operations on the address and data buses (Slide 12).\n\nBuses can be either **dedicated** or **multiplexed**, **synchronous** or **asynchronous**, depending on the system's requirements for speed, cost, and complexity (Slide 12).\n\n## Learning Outcomes\n\nBy understanding the different types of buses, operations, arbitration schemes, and bus components, one can design effective **SoC and SOPC** systems that balance performance, cost, and complexity. Key takeaways include:\n\n-   The importance of selecting appropriate **bus width** to match system requirements while considering cost implications.\n\n-   Differences between **synchronous** and **asynchronous** buses and the trade-offs involved in choosing one over the other.\n\n-   The necessity of **bus arbitration** in multi-master systems to ensure fair access and system efficiency.\n\n-   How different arbitration policies impact bus access, latency, and fairness.\n\nThe **building blocks of an SoC or SOPC**—including **masters (e.g., processors, DMA controllers)**, **slaves (e.g., peripherals)**, **buses**, **decoders**, and **arbiters**—all work together to create a cohesive, functional system capable of handling complex tasks (Slide 53).\n\n## Conclusion\n\nThe lecture provided a comprehensive overview of **bus design and operations** in SoC and SOPC systems. Understanding bus types, operations, arbitration, and implementation is crucial for designing efficient and scalable embedded systems. These principles are applied to ensure that various components within a SoC or SOPC can communicate effectively while meeting performance requirements.\n\nFuture discussions will explore **on-chip interconnects**, **crossbars**, and **network-on-chip (NoC)** architectures, which are becoming increasingly relevant for **multi-core SoC designs** that demand higher data throughput and efficient parallel processing.","srcMarkdownNoYaml":""},"formats":{"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":true,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":false,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"latexmk","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":["../preamble.tex"],"pdf-engine-opts":["-synctex=1","-interaction=nonstopmode","-file-line-error","-lualatex","-shell-escape"],"toc":true,"toc-depth":3,"number-sections":true,"output-file":"lecture5_sopc_buses.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"title":"COMPSYS 303: Microcomputers and Embedded Systems","subtitle":"Lecture Notes","author":"Nicholas Russell","date":"10/05/2024","date-format":"full","hyperrefoptions":["pdfpagelabels"],"documentclass":"scrreprt","fontsize":"14pt","papersize":"a4","pagestyle":"plain","classoption":["headinclude=true","footinclude=true","DIV=calc"],"geometry":["top=3cm","bottom=3cm","left=1.5cm","right=1.5cm"],"fontfamily":"lmodern"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["pdf"]}