{"title":"COMPSYS 303: Microcomputers and Embedded Systems","markdown":{"headingText":"SCCharts and Synchronous Concurrency","containsRefs":false,"markdown":"<!-- lecture2_sccharts.qmd -->\n\n\n## Introduction to Synchronous Concurrency and SCCharts\n\nSynchronous Concurrency (SC) is a method used to manage the complexity of Cyber-Physical Systems (CPS) by providing deterministic behavior and efficient handling of concurrent processes. SCCharts are a powerful visual formalism used to model concurrent, reactive, and real-time behaviors in embedded systems. They offer a way to design systems that react to changes in the environment while maintaining reliable and predictable execution.\n\n## The Synchronous Approach\n\nThe **synchronous approach** is a paradigm in which all concurrent processes are assumed to execute in lockstep relative to a global logical clock. This provides a deterministic and predictable execution model, which is highly beneficial for embedded systems that operate in safety-critical environments.\n\nKey aspects of the synchronous approach include:\n\n-   **Synchrony Hypothesis:** This hypothesis assumes that the system's reactions occur infinitely faster than the environment, leading to a **zero-delay model**. This means that the reaction to an input is instantaneous from the system's perspective, ensuring a deterministic response.\n\n-   **Synchronous Threading and Broadcast Communication:** All concurrent threads execute synchronously, meaning that outputs generated by one component are immediately visible to all other components. This approach resembles **synchronous circuits**, where each clock tick coordinates all activities, providing atomic and instantaneous reactions.\n\n-   **Atomicity and Instantaneity of Reactions:** The synchronous approach treats reactions as atomic, meaning that no intermediate states are visible during execution. This helps prevent issues like race conditions, which are prevalent in asynchronous systems.\n\n-   **Reaction to Absence:** The system can react not only to events that occur but also to the absence of expected events, allowing for a more comprehensive model of environmental interaction.\n\n## SCCharts Overview\n\n**SCCharts** are an extension of Statecharts, introduced by David Harel, that add the benefits of the synchronous paradigm to the powerful modeling features of Statecharts. SCCharts are used to describe complex systems involving multiple states and concurrent processes. It's also a sh\\*t piece of under engineered German software from Kiel.\n\n### Similarities and Differences Between SCCharts and Statecharts\n\n-   **Similarities:** Both SCCharts and Harel's Statecharts share common elements such as states, transitions, signals/events, and modularity. They both support **hierarchy**, **parallelism**, and **broadcast communication** between states, which allows for more compact and expressive models.\n\n-   **Differences:** SCCharts operate within a **synchronous framework** and guarantee deterministic behavior, which contrasts with the often non-deterministic nature of Statecharts. SCCharts do not interpret events for simulations, which eliminates hidden behaviors and allows for more precise analysis. SCCharts also do not support **inter-level transitions** and provide deterministic handling of concurrent events, which simplifies debugging and validation.\n\n## Boolean Mealy Machine (BMM)\n\nAn SCChart can be represented using a **Boolean Mealy Machine (BMM)**. A BMM is defined as a tuple $M = \\langle Q, q_0, I, O, T \\rangle$, where:\n\n-   $Q$ is the set of states.\n\n-   $q_0$ is the initial state.\n\n-   $I$ is the set of inputs.\n\n-   $O$ is the set of outputs.\n\n-   $T$ is the transition relation, involving states and boolean conditions on inputs.\n\nBMMs provide a formal basis for understanding how SCCharts operate, with transitions being defined based on the current state and inputs. The key properties of BMMs are **determinism** and **reactivity**:\n\n-   **Determinism**: At most one transition is enabled for any valid combination of inputs from the environment. This ensures that the system behaves predictably regardless of concurrent events.\n\n-   **Reactivity**: At least one transition is enabled for any valid combination of inputs, ensuring the system can always respond appropriately to environmental changes.\n\n## The VABRO Example\n\nThe **Valued ABRO (VABRO)** example, which is an adaptation of Berry's **ABRO**, is used to demonstrate the synchronous programming model. In this example, the system generates an output when two specific inputs have occurred. The model incorporates **strong pre-emption**, allowing the behavior to be reset when a particular condition is met. VABRO demonstrates how SCCharts can handle complex state-based logic, including counting events and generating output values based on conditions.\n\n## Constructiveness in Synchronous Systems\n\n**Constructiveness** is an important concept in synchronous systems, ensuring that concurrent processes do not interfere with each other's operation. **Berryâ€™s Constructiveness** requires that all reads happen only after writes to shared entities are completed, and that there is at most one write to any shared entity during a reaction. This ensures consistency and prevents conflicting updates during a single tick of the logical clock.\n\n**Sequential Constructiveness** extends Berry's constructiveness by allowing sequential updates to shared variables under certain conditions. The **Init-Update-Read (IRU) protocol** is used to manage variable updates in the following order:\n\n1.  **Initialization**: Concurrent threads can make confluent initializations to shared variables, provided they assign the same value.\n\n2.  **Update**: Threads update shared variables using the same update function, ensuring confluent updates.\n\n3.  **Read**: Finally, threads are allowed to read the updated value, guaranteeing consistency.\n\n## Timed SCCharts and Real-Time Systems\n\n**Timed SCCharts** add temporal constraints to SCCharts, enabling the modeling of **real-time systems** where timing is crucial. These models can compute the **Worst Case Reaction Time (WCRT)** and adjust the tick length accordingly to ensure the system meets its timing requirements. By counting ticks, timed SCCharts allow real-time systems to be modeled effectively, ensuring that actions are taken within the required time frame.\n\n**Dynamic Ticks** are also introduced to allow the system to adjust tick lengths dynamically, providing more flexibility in real-time operation. This flexibility is essential for systems that need to adapt to changing conditions, such as varying processing loads or external inputs that influence timing requirements.\n\n## Designing Real-Time Systems with SCCharts\n\nThe synchronous approach is particularly suitable for **real-time systems**, where deterministic behavior is essential for safety and reliability. By using SCCharts:\n\n-   **Concurrency is managed in a deterministic manner**, ensuring that all processes execute predictably without interference or unintended interactions.\n\n-   **Pre-emption and Suspension** are modeled explicitly, allowing designers to represent high-priority tasks interrupting lower-priority tasks, or suspending ongoing activities until a condition is met.\n\n-   The **generated code from SCCharts** compiles the concurrent specifications into sequential code, which is efficient and suitable for **bare metal implementations** without requiring an operating system. This makes SCCharts an excellent choice for systems with constrained resources, such as microcontrollers in embedded environments.\n\n## Conclusion\n\nSynchronous concurrency, as implemented using SCCharts, provides a robust framework for designing **deterministic, reactive, and real-time embedded systems**. By combining the power of Statecharts with the guarantees of the synchronous model, SCCharts offer a visual and formal way to specify complex concurrent behavior while ensuring predictable execution. The **synchronous approach** is well-suited for **safety-critical CPS** applications, such as medical devices, automotive systems, and robotics, where the cost of failure is high.\n\nFuture discussions will delve deeper into **synchronous pre-emption**, **timed automata**, and how SCCharts can be extended to model more complex temporal behaviors. These tools and concepts are crucial for ensuring that CPS can meet their real-time requirements in a safe and reliable manner.","srcMarkdownNoYaml":""},"formats":{"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":true,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":false,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"latexmk","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":["../preamble.tex"],"pdf-engine-opts":["-synctex=1","-interaction=nonstopmode","-file-line-error","-lualatex","-shell-escape"],"toc":true,"toc-depth":3,"number-sections":true,"output-file":"lecture2_sccharts.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"title":"COMPSYS 303: Microcomputers and Embedded Systems","subtitle":"Lecture Notes","author":"Nicholas Russell","date":"10/05/2024","date-format":"full","hyperrefoptions":["pdfpagelabels"],"documentclass":"scrreprt","fontsize":"14pt","papersize":"a4","pagestyle":"plain","classoption":["headinclude=true","footinclude=true","DIV=calc"],"geometry":["top=3cm","bottom=3cm","left=1.5cm","right=1.5cm"],"fontfamily":"lmodern"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["pdf"]}