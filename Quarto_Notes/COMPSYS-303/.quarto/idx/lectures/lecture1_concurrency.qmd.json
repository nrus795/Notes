{"title":"COMPSYS 303: Microcomputers and Embedded Systems","markdown":{"headingText":"Concurrency","containsRefs":false,"markdown":"<!-- lecture1_concurrency.qmd -->\n\n\n## Introduction to Embedded Systems and Concurrency\n\nEmbedded systems are a specialized class of computers designed to continuously interact with their environment in a real-time, often reactive manner. Unlike general-purpose computers, embedded systems are purpose-built to handle specific tasks under stringent conditions, including timing constraints. These systems are embedded as integral parts of larger devices and must operate dependably, often without human intervention. Examples include automotive control systems, medical devices like pacemakers, and consumer electronics such as washing machines.\n\nWhen deadlines must be met without exception, the system is termed a **hard real-time system**; otherwise, it is a **soft real-time system**. In hard real-time systems, any missed deadline could result in catastrophic failure, such as in medical devices or automotive safety features. In contrast, soft real-time systems can tolerate occasional missed deadlines, although they may affect performance.\n\nThe concept of **concurrency** is crucial in embedded systems because these systems often involve multiple processes interacting simultaneously, such as a pacemaker continuously monitoring the heart and delivering pulses when needed. Concurrency enables these systems to effectively manage different tasks that need to be performed either synchronously or asynchronously. For example, while monitoring the heart, a pacemaker must also manage pulse delivery in real-time, demonstrating the need for concurrent tasks.\n\n## Key Concepts in Concurrency\n\n**Concurrency** refers to multiple components or processes operating at the same time within a system. In embedded systems like pacemakers, various components (controllers, sensors, and timers) work concurrently to ensure precise timing between events. Concurrency becomes especially challenging when different tasks access shared resources simultaneously, potentially leading to issues such as **race conditions**, **deadlocks**, and **livelocks**.\n\n-   **Race Conditions:** These occur when two or more processes access shared data concurrently, and the final result depends on the timing of their access. A typical example is the producer-consumer problem, where one process generates data while another consumes it. If these processes do not manage shared data properly, inconsistencies may arise. For instance, if two processes increment a shared counter without proper synchronization, the final value of the counter may be incorrect due to overlapping access. This issue is exacerbated in systems with multiple cores or processors, where different threads can execute simultaneously.\n\n-   **Critical Sections and Mutual Exclusion:** A **critical section** is a part of a program that should only be executed by one process at a time to avoid data corruption. Ensuring **mutual exclusion**, where no two processes are in their critical sections simultaneously, is essential for preventing race conditions. Mutual exclusion can be achieved using synchronization mechanisms like **locks**, which ensure that only one process can access the critical section at any given time. Common techniques include **mutexes** and **binary semaphores**, both of which can lock shared resources to ensure orderly access. It is also important to minimize the time a process spends in a critical section to reduce the chances of blocking other processes.\n\n**Deadlocks and Livelocks:**\n\n-   **Deadlocks** occur when processes are waiting on each other indefinitely, leading to a situation where no progress can be made. This typically happens in resource allocation scenarios where two or more processes form a circular chain of dependencies. A classic example is two processes holding a resource that the other needs to proceed, resulting in a stalemate.\n\n-   **Livelocks** are similar to deadlocks but differ in that processes keep changing state in response to each other without making any actual progress. Both issues are critical in concurrent systems and need to be addressed through careful design, such as avoiding circular waiting conditions, implementing resource hierarchies, or using **deadlock detection algorithms** that can detect and break deadlocks. Timeout mechanisms can also be used to release resources if a process waits too long.\n\n## Approaches to Manage Concurrency\n\nConcurrency in embedded systems is managed through a combination of hardware and software synchronization mechanisms. Some of the methods discussed include:\n\n**Busy Waiting and Non-Busy Waiting:**\n\n-   **Busy waiting** occurs when a process remains in the ready state, actively checking for a condition to be satisfied. This approach is inefficient in terms of CPU utilization, as the CPU is occupied with checking instead of performing useful work.\n\n-   **Non-busy waiting** solutions, such as putting a process in the blocked state while waiting for a resource, are more efficient for embedded systems where CPU resources are limited. Busy waiting is often used in systems where the wait time is expected to be very short, whereas non-busy waiting is preferred for longer wait times to free up CPU resources. In embedded systems, avoiding busy waiting is crucial because the CPU often needs to manage multiple tasks under strict timing constraints.\n\n-   **Test and Set Instruction:** The **Test and Set** instruction is an atomic operation used to achieve mutual exclusion by using a global variable to indicate whether a critical section is occupied. By using Test and Set, embedded systems can ensure that processes access shared resources in a predictable and coordinated manner. The atomicity of this instruction prevents race conditions by ensuring that the check-and-set operation is performed without interruption. However, Test and Set can lead to **busy waiting**, which may not be suitable for all embedded applications. In systems with limited processing power or battery life, busy waiting can degrade performance and reduce efficiency.\n\n**Semaphores and Mutex Locks:**\n\n-   **Semaphores** are synchronization mechanisms used to manage concurrent access to shared resources. They allow processes to signal and wait for access, ensuring a controlled flow of execution. Semaphores can be **binary** (acting like a mutex) or **counting**, allowing a specified number of processes to access a resource concurrently. For example, counting semaphores are often used in producer-consumer scenarios where multiple producers or consumers need access to a shared buffer.\n\n-   **Mutex locks** are similar but are typically used to protect access to a particular data structure or variable, providing mutual exclusion in critical sections. Mutexes are often simpler to implement but are limited to binary states (locked or unlocked), whereas semaphores offer more flexibility for resource management.\n\n**Priority Inversion and Solutions:**\n\n-   **Priority inversion** occurs when a higher-priority task is waiting for a resource held by a lower-priority task, which can lead to missed deadlines in real-time systems. A well-known example is the **Mars Pathfinder mission**, where a low-priority task holding a shared resource caused a higher-priority task to miss its deadline, resulting in system resets.\n\n-   **Solutions** to priority inversion include **priority inheritance**, where the lower-priority task temporarily inherits the higher priority to complete its task and release the resource. Another approach is **priority ceiling**, where a resource is assigned a priority equal to the highest priority of any task that may lock it, thus preventing priority inversion.\n\n## Examples and Applications\n\nThe lecture provided various examples of where concurrency is critical, including the automotive industry and robotics. For instance, the **2010 Toyota recall** was attributed to software issues in their anti-lock braking systems, highlighting the importance of deterministic behavior in safety-critical systems. This incident shows how improperly managed concurrency can lead to life-threatening failures. Similarly, **Tesla's accidents** were referenced, emphasizing the challenges of building reliable autonomous systems. These examples underscore the need for proper concurrency management to ensure system reliability and safety.\n\nIn embedded systems such as a **pacemaker**, concurrency is an intrinsic characteristic. The pacemaker must concurrently monitor the heart and trigger electrical pulses without delay, thus operating as a real-time reactive system. Concurrency, in this context, is about ensuring different components work seamlessly together to meet life-critical deadlines. The pacemaker example illustrates how timing constraints and concurrent interactions must be carefully managed to avoid potentially fatal outcomes. The system must ensure that sensing, decision-making, and actuation are carried out with precise timing to maintain patient safety.\n\n## Problems with Concurrency and Solutions\n\nConcurrency can lead to serious issues if not properly managed. (Haha, kieler go brrrrr)\n\n**Deadlocks**\n\n-   **Deadlocks** occur when concurrent processes are waiting on each other to release resources, resulting in a state where no process can proceed. To prevent deadlocks, proper scheduling mechanisms must be implemented to ensure that resource allocation does not lead to circular waiting. **Deadlock prevention techniques** include resource ordering, where resources are always requested in a specific order, and **deadlock detection algorithms** that periodically check for cycles in the resource allocation graph. Another approach is **deadlock avoidance**, such as using the **Banker's algorithm**, which allocates resources in a way that ensures a safe state is always maintained.\n\n**Fairness and Scheduling**\n\n-   **Fairness** in resource allocation means that every process eventually gets a chance to execute. Embedded systems often use a **scheduler** to manage processes, ensuring tasks are completed in a timely and fair manner. The role of the scheduler is critical to prevent **starvation**, where some tasks never get executed due to others continuously consuming resources.\n\n-   Common **scheduling** algorithms include **round-robin**, **priority-based**, and **rate-monotonic scheduling**, each with its own advantages and trade-offs depending on the system requirements. **Round-robin scheduling** is simple and ensures fairness by giving each process a fixed time slice, while **priority-based scheduling** allows more critical tasks to execute first but can lead to starvation without priority aging.\n\n**Starvation**\n\n-   **Starvation** occurs when a process is perpetually denied the resources it needs to execute, often because other higher-priority processes continuously take precedence. To mitigate starvation, **priority aging** can be used, where the priority of a waiting process is gradually increased over time to ensure it eventually gets the necessary resources. This technique ensures that lower-priority processes are not starved indefinitely, especially in systems with many competing processes.\n\n## Conclusion\n\nConcurrency is an essential aspect of embedded systems, particularly for reactive, real-time applications. This lecture emphasized the importance of understanding the mechanisms—such as **mutual exclusion**, **semaphores**, and **scheduling**—that help manage concurrent processes effectively. For embedded systems like automotive controls, pacemakers, or industrial automation, **deterministic behavior** and avoiding race conditions are paramount. Properly handling concurrency ensures that embedded systems can meet their timing constraints, maintain data consistency, and operate safely under all conditions.\n\nNext steps in the lecture will involve exploring **reactive systems** and how **synchronous concurrency** can be implemented to further ensure the reliability of embedded systems. Understanding these concepts is vital for designing embedded systems that are safe, reliable, and efficient. Future topics will also cover specific synchronization protocols and **real-time operating system (RTOS)** features that support concurrency in embedded environments. Additionally, understanding how to leverage hardware features, such as **interrupt controllers** and **timers**, will be crucial for achieving precise control over concurrent tasks in embedded systems.","srcMarkdownNoYaml":""},"formats":{"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":true,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":false,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"latexmk","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":["../preamble.tex"],"pdf-engine-opts":["-synctex=1","-interaction=nonstopmode","-file-line-error","-lualatex","-shell-escape"],"toc":true,"toc-depth":3,"number-sections":true,"output-file":"lecture1_concurrency.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"title":"COMPSYS 303: Microcomputers and Embedded Systems","subtitle":"Lecture Notes","author":"Nicholas Russell","date":"10/05/2024","date-format":"full","hyperrefoptions":["pdfpagelabels"],"documentclass":"scrreprt","fontsize":"14pt","papersize":"a4","pagestyle":"plain","classoption":["headinclude=true","footinclude=true","DIV=calc"],"geometry":["top=3cm","bottom=3cm","left=1.5cm","right=1.5cm"],"fontfamily":"lmodern"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["pdf"]}