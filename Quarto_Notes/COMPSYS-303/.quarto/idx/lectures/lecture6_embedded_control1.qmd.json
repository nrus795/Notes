{"title":"COMPSYS 303: Microcomputers and Embedded Systems","markdown":{"headingText":"Embedded Control Systems 1","containsRefs":false,"markdown":"<!-- lecture6_embedded_control1.qmd -->\n\n\n## Introduction to Embedded Control Systems\n\n**Embedded control systems** are crucial for industrial automation and other real-time applications that require precise, timely responses. These systems often control physical processes, ensuring safety and reliability through careful computational analysis of execution times. This lecture focused on various elements of embedded control, such as real-time system properties, sampling and quantization, computational delays, and worst-case execution time (WCET) analysis (Slides 2-3).\n\n## Real-Time Systems\n\n**Definition**: Real-time systems are used in scenarios where timing is critical, such as industrial automation and safety-critical applications. These systems must perform their functions not only correctly (functional correctness) but also within specific timing constraints (Slide 3).\n\n**Examples**: A robotic arm must stop within 10 ms of detecting human intrusion to prevent accidents. This combination of functional and timing correctness is what defines a real-time system.\n\n## Sampling and Quantization\n\n**Sampling**: Sampling refers to taking discrete snapshots of an analog signal over time. This process is fundamental in digitizing signals like video, audio, or physical voltages. The higher the sampling rate, the more accurately the original signal is represented (Slides 4, 8).\n\n**Quantization**: Due to the discrete nature of computer data, real values must be approximated to the nearest value in a finite set. Quantization replaces real-world continuous values with discrete levels, introducing **quantization error** (Slide 5).\n\n-   **Quantization Levels**: For an `n`-bit Analog-to-Digital Converter (ADC), there are $2^n$ levels, which determine how finely the signal is represented. For example, an 8-bit ADC has 256 quantization levels.\n\n-   **Resolution**: The resolution of an ADC determines the voltage represented by each digital increment. For instance, a 10-bit ADC with a High Reference Voltage (HRV) of 5V and Low Reference Voltage (LRV) of 0V has a resolution of approximately 0.00488V per step (Slide 6).\n\n## Aliasing\n\n**Aliasing** occurs due to insufficient sampling rates. If the sampling rate is less than twice the frequency of the signal (the **Nyquist frequency**), higher-frequency signals appear indistinguishable from lower frequencies, leading to errors (Slides 9-11). For example, if a signal is sampled at 2.5 Hz, signals at 0.5 Hz, 3 Hz, and 5.5 Hz appear the same, leading to ambiguity.\n\n## Computation Delays and Timing Variances\n\n**Computation Delays**: In real-time systems, delays can occur due to inherent processing overhead, causing sampling or actuation to happen later than expected. Accurate delay characterization is needed to ensure that systems meet timing requirements (Slide 12).\n\n**Sources of Timing Variance**:\n\n-   **Unbounded Software Constructs**: Unpredictable branches, loops, recursion, and dynamic memory allocations can introduce delays (Slide 13).\n\n-   **Speculative Hardware**: Features like pipelines, memory hierarchies (caches), and branch predictors in modern processors can lead to non-deterministic execution times.\n\n## Worst-Case Execution Time (WCET)\n\n**WCET** is the maximum time required for a system to complete a given task (Slide 14). Understanding WCET is critical for ensuring that an embedded control system meets its real-time constraints.\n\n**Methods to Determine WCET**:\n\n-   **Measured**: Simple to implement but may not explore all possible execution paths, thus providing non-guaranteed values.\n\n-   **Static Analysis**: Uses an abstraction of the system to analyze all possible paths, ensuring coverage but requiring significant computational resources.\n\n## Static Timing Analysis\n\n**Control Flow Graph (CFG)**: Timing analysis starts with creating a **control flow graph** (CFG) to map program flow, representing different segments of code (Slides 18-19).\n\n-   **Basic Blocks and Transitions**: CFG nodes are called **basic blocks**, which represent straight-line code without branches, and transitions show how the program moves between these blocks.\n\n-   **Path Analysis**: Finding the **longest execution path** within the CFG is key to determining the worst-case scenario for execution time (Slide 20).\n\n**Timed CFG**: A timed CFG uses clock cycle estimates for different operations—computation, load, store, branch, and return—to determine execution duration (Slide 23).\n\n-   Example: **Load** and **Store** take 5 cycles, **Computation** takes 1 cycle, **Branch** (if taken) takes 3 cycles.\n\n## WCET Analysis Using Max-Plus Algebra\n\nThe **Max-Plus** approach simplifies WCET analysis by using only max and plus operations to calculate the worst-case path cost (Slide 24).\n\n-   For example, the WCET for two possible paths might be calculated as: $\\text{wcet} = \\max(19 + 14 + 10, 21 + 13 + 10) = 44$ clock cycles.\n\n## Integer Linear Programming (ILP)\n\n**ILP** is used for WCET analysis by defining an **objective function** to maximize execution time under given constraints (Slide 28-30). The constraints are typically linear inequalities describing valid program transitions and flow consistency, allowing ILP to provide an upper bound for WCET.\n\n## Coding Guidelines for Time Predictability\n\n-   **Bounded Loops**: Always use bounded loops to guarantee an upper bound on execution time (Slide 36). For example, in the **GCD** function, the loop is bounded to ensure a predictable runtime.\n\n-   **Static Memory Allocation**: Prefer static allocation over **dynamic memory allocation** (e.g., `malloc`) to prevent runtime unpredictability caused by memory fragmentation or variable allocation times (Slide 38).\n\n-   **Avoiding Interrupts**: Where possible, avoid **interrupts** due to their impact on execution time variability. Instead, use polling or reactive processors that can queue interrupts predictably (Slide 39).\n\n-   **Fixed Point Arithmetic**: Use **fixed-point arithmetic** over floating-point for better predictability, as floating-point operations are not always supported natively and can have variable runtime characteristics.\n\n## PRET Philosophy\n\nThe **PRET (Precision Timed)** philosophy emphasizes treating time as a first-class citizen, aiming for a **time-predictable system** (Slide 35). The objective is to achieve predictability in hardware, software-hardware interfaces, and the software itself, ensuring reliable operation within a time-constrained environment.\n\n## Conclusion\n\nThis lecture provided insights into the design and analysis of **embedded control systems**. Key topics included **real-time system requirements**, **sampling and quantization**, **computation delays**, **WCET analysis**, and **coding practices for time predictability**. Accurate timing analysis and predictable software execution are crucial for the development of safe and reliable embedded control systems. The concepts discussed lay the foundation for designing robust control systems that meet strict real-time requirements.","srcMarkdownNoYaml":""},"formats":{"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":true,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":false,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"latexmk","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":["../preamble.tex"],"pdf-engine-opts":["-synctex=1","-interaction=nonstopmode","-file-line-error","-lualatex","-shell-escape"],"toc":true,"toc-depth":3,"number-sections":true,"output-file":"lecture6_embedded_control1.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"title":"COMPSYS 303: Microcomputers and Embedded Systems","subtitle":"Lecture Notes","author":"Nicholas Russell","date":"10/05/2024","date-format":"full","hyperrefoptions":["pdfpagelabels"],"documentclass":"scrreprt","fontsize":"14pt","papersize":"a4","pagestyle":"plain","classoption":["headinclude=true","footinclude=true","DIV=calc"],"geometry":["top=3cm","bottom=3cm","left=1.5cm","right=1.5cm"],"fontfamily":"lmodern"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["pdf"]}