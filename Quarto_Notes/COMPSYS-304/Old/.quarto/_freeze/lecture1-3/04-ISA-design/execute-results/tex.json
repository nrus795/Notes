{
  "hash": "907d694ea79e993c63193dad1099a01e",
  "result": {
    "engine": "jupyter",
    "markdown": "# Instruction Set Architecture Design\n\n## [Comparing different Instruction Set Architectures.]{color=\"red\"}\n\n[**Which one is the best? (for our example: C = A + B)**]{color=\"red\"}\n\n::: {.cell cache='false' execution_count=1}\n\n::: {.cell-output .cell-output-display}\n![](04-ISA-design_files/figure-pdf/isa-table-output-1.pdf){#isa-table fig-align='center'}\n:::\n:::\n\n\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxheadcol, coltitle=boxtitlecol, colbacktitle=boxheadcol, title=Basic ISA Classes\"}\nInstruction set architectures (ISA) are generally classified based on:\n- the instruction word size (how many bytes for encoding each instruction)\n- the number of different instructions in the ISA\n- the number of clock cycles required to complete each instruction (which can be implementation dependent)\n:::\n\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\nBased on that, the following have been specified as different ISA classes:\n\n- [**RISC**]{color=red} (Reduced Instruction Set Computers): where the size of the instruction word for all instructions are the same. This may lead to simpler decoding hardware. For example, **MIPS** (or RISC-V) processors use this type of ISA.\n\n- [**CISC**]{color=red} (Complex Instruction Set Computers): where the size of the instruction word may be different for different instructions. This results in more complex decoding hardware but the code footprint (binary code size of the program) can be less. for example, **Intel X86** based processors are based on this type of ISA.\n\n- [**EPIC**]{color=red} (Explicitly Parallel Instruction Computers): In this case, parallel operations are explicitly encoded in the instruction. The compiler plays a more important role in EPIC architectures. For example, **Intel Itanium** is based on this type of ISA.\n:::\n\n## Different levels of abstraction [(Software)]{color=\"red\"}\n\n<!-- ! PLACEHOLDER ! -->\n\n\n\n\n{{< placeholder >}}\n\n\n\n\n\n\n\n<!-- TODO: implement the diagram from notes -->\n\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxheadcol\"}\nAn abstraction removes unnecessary detail, helps us cope with the complexity. More hardware details are considered in programming through moving from [**High-Level Language**]{color=red} to [**Machine Language**]{color=red}.\n:::\n\n## [Basic steps in a CPU]{color=red} for \\underline{Instruction Processing}\n\n::: {layout=\"[30,70]\" fig-pos=\"H\"}\n::: {#first-column}\n<!-- ! PLACEHOLDER ! -->\n\n\n\n\n{{< placeholder >}}\n\n\n\n\n\n\n\n:::\n\n::: {#second-column}\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxheadcol, colbacktitle=boxheadcol, title=\\\\textcolor{red}{\\\\underline{\\\\textbf{Fetching}}}\"}\n\\underline{\\textbf{Access memory to get the next instruction:}}\nActivate memory read signal, place the right memory address on address lines, read the content of memory pointed by the address.\n:::\n:::\n:::\n\n::: {layout=\"[30,70]\" fig-pos=\"H\"}\n::: {#first-column}\n<!-- ! PLACEHOLDER ! -->\n\n\n\n\n{{< placeholder >}}\n\n\n\n\n\n\n\n:::\n\n::: {#second-column}\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxheadcol, colbacktitle=boxheadcol, title=\\\\textcolor{red}{\\\\underline{\\\\textbf{Decoding}}}\"}\n\\underline{\\textbf{Interpret the bits of the instruction word:}} to identify the operation and its data (which might be taken from memory or registers)\n:::\n:::\n:::\n\n::: {layout=\"[30,70]\" fig-pos=\"H\"}\n::: {#first-column}\n<!-- ! PLACEHOLDER ! -->\n\n\n\n\n{{< placeholder >}}\n\n\n\n\n\n\n\n:::\n\n::: {#second-column}\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxheadcol, colbacktitle=boxheadcol, title=\\\\textcolor{red}{\\\\underline{\\\\textbf{Execution}}}\"}\n\\underline{\\textbf{Perform that specific operation:}} Use the processor resources to perform the operation and write the result to memory or register if necessary\n:::\n:::\n:::\n\n::: {.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\n- What type of operations are needed?\n:::\n\n<!-- ! bloody table... -->\n\n::: {.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\n- How operands (data) are provided in each instruction?\n:::\n[**through registers except for \\underline{\\textit{load}} and \\underline{\\textit{store}} instructions which will access memory too.**]{color=\"red\"}\n\n::: {.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\n- Size of Instruction word and Data word?\n:::\n[**32 bits**]{color=red}\n\n## [\\underline{Summary of Our Design Decisions:}]{color=red}\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\n- \\underline{\\textbf{RISC ISA:}} All instructions have the same size\n    - **load/store architecture** (only [*load*]{color=red} and [*store*]{color=red} instructions can access memory).\n    - Other instructions use registers\n- [**Data word:**]{color=red} 32 bits (4 bytes)\n- [**Instruction word:**]{color=red} 32 bits (4 bytes)\n- [**Registers**]{color=red} 32 general purpose 32-bit registers\n- [**Size of Addressable Memory:**]{color=red} $ 2^32 $ (each memory address is 32 bits)\n- [**Operands:**]{color=red} Signed, unsigned, immediate\n\n*To make the implementation simpler and faster, the number of instructions in the ISA should be reduced as much as possible*\n\nALU operations are performed on:\n- data from registers, or\n- immediate value (data encoded into the instruction word)\n:::\n\n:::{.tcolorbox options=\"colback=boxbodycol2, colframe=boxheadcol2, title=\\\\underline{\\\\textbf{ALU operations}}, coltitle=boxtitlecol2, colbacktitle=boxheadcol2\"}\n- [**addition**]{color=red}\\\n**Both input data from registers (signed)** [**add**]{color=red} [***add, Rd, Rs, Rt***]{color=blue}\\\n**Both input data from registers (unsigned)** [**addu**]{color=red} [***addu, Rd, Rs, Rt***]{color=blue}\\\n**One input data as immediate value** [**addi**]{color=red} [***addi, Rt, Rs, immed.***]{color=blue}\n- [**subtraction**]{color=red}\\\n**Both input data from registers (signed)** [**sub**]{color=red} [***sub, Rd, Rs, Rt***]{color=blue}\\\n**Both input data from registers (unsigned)** [**subu**]{color=red} [***subu, Rd, Rs, Rt***]{color=blue}\n- [**AND**]{color=red}\\\n**Both input data from registers (signed)** [**and**]{color=red} [***and, Rd, Rs, Rt***]{color=blue}\\\n**One input data as immediate value** [**andi**]{color=red} [***andi, Rt, Rs, immed.***]{color=blue}\n- [**OR**]{color=red} [**or, ori**]{color=red} \n:::\n\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxheadcol, colbacktitle=boxheadcol, title=Shift operations, coltitle=boxtitlecol\"}\n\n\n\n\n{{< placeholder >}}\n\n\n\n\n\n\n\n:::{.tcolorbox options=\"oversize, left=11pt, right=11pt, colback=boxbodycol2, colframe=boxheadcol2, title=Example, coltitle=boxtitlecol2, colbacktitle=boxheadcol2\"}\nAssume that the contents of register R1 is as follows:\\\n[**1000 0000 1100 1010 0001 0111 0001 1110**]{color=red}\\\nAfter shifting two times to the left the following number is in register R1:\\\n[**0000 0011 0010 1000 0101 1100 0111 1000**]{color=red}\n:::\n:::\n\n:::{.tcolorbox options=\"colback=boxbodycol3, colframe=boxbodycol3\"}\n[**sll, sllv**]{color=blue} shift left logical [***sllv Rd, Rs, Rt***]{color=red}\\\n[**srl, srlv**]{color=blue} shift right logical [***srl Rd, Rs, immediate***]{color=red}\\\n[**sra, srav**]{color=blue} shift right arithmetic [***srav Rd, Rs, Rt***]{color=red}\n:::\n\n\n\n\n\n{{< placeholder >}}\n\n\n\n\n\n\n\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\nShift instructions can be used in arithmetic operations (multiplying or dividing by a number which is a power of 2). The number of bits to be shifted can be given as a constant value or the contents of the second source register can be used to determine how many bits to be shifted.\n:::\n\n\n\n\n{{< pagebreak >}}\n\n\n\n\n\n\n\n[***\\underline{A few points to remember:}***]{color=red}\n\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\n- In the instruction representation (in our case), always the [*destination register*]{color=red} is written first and then the [*source registers*]{color=red} (this convention may be different for other processors).\n- Registers in the instructions are represented using \\ $reg_num. (for example, register 1 is [\\$1]{color=red} and register 15 is [\\$15]{color=red}).\n- In our ISA (MIPS ISA) the contents of Register 0 (\\$0) is 0000 0000 0000 0000 0000 0000 0000 0000 and register \\$ cannot be written. (It is hardwired to 0)\n:::\n\n## [\\underline{\\textit{Examples of the MIPS ALU Instructions:}}]{color=red}\n\n:::{.tcolorbox options=\"colback=boxbodycol, colframe=boxbodycol\"}\n\n:::\n\n",
    "supporting": [
      "04-ISA-design_files"
    ],
    "filters": []
  }
}